<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script>
// =================================================================
//  GIGA Game Architect - Game Engine (Zero-Lag Version)
//  ã‚¢ãƒ—ãƒªå: ã‚«ãƒ™åˆæˆ¦ï¼
// =================================================================

// --- 1. ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ç®¡ç† (State Management) ---
const GAME_CONFIG = {
  p1Color: 'é’',
  p2Color: 'èµ¤',
  p1Class: 'p1',
  p2Class: 'p2'
};

let gameState = {
  boardSize: 9,      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯9x9
  players: {},       // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®æƒ…å ±
  walls: [],         // è¨­ç½®ã•ã‚ŒãŸã‚«ãƒ™ {row, col, orientation}
  turn: 1,           // 1: é’ãƒãƒ¼ãƒ , 2: èµ¤ãƒãƒ¼ãƒ 
  wallsLeft: { 1: 10, 2: 10 },
  winner: null,
  mode: 'move',      // 'move' (ç§»å‹•) or 'wall' (ã‚«ãƒ™)
  wallOrientation: 'v' // 'v' (ã‚¿ãƒ†) or 'h' (ãƒ¨ã‚³)
};

// --- 2. åˆæœŸåŒ–ã¨DOMã‚¤ãƒ™ãƒ³ãƒˆ (Initialization) ---
document.addEventListener('DOMContentLoaded', () => {
  // åˆæœŸè¨­å®šç”»é¢ã®è¡¨ç¤º
  setupGameDOM();
  
  // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
  document.getElementById('btn-start').addEventListener('click', () => {
    const size = parseInt(document.getElementById('select-board-size').value);
    initGame(size);
  });

  // æ“ä½œãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³
  document.getElementById('btn-mode-move').addEventListener('click', () => setMode('move'));
  document.getElementById('btn-mode-wall').addEventListener('click', () => setMode('wall'));
  document.getElementById('btn-rotate-wall').addEventListener('click', toggleWallOrientation);
  
  // ãƒ«ãƒ¼ãƒ«ãƒœã‚¿ãƒ³
  document.getElementById('btn-rule').addEventListener('click', showRules);
});

// UIã®åˆæœŸçŠ¶æ…‹ã‚’ã‚»ãƒƒãƒˆã™ã‚‹é–¢æ•°
function setupGameDOM() {
  document.getElementById('setup-screen').classList.remove('d-none');
  document.getElementById('game-screen').classList.add('d-none');
  document.getElementById('game-message').textContent = 'æº–å‚™ä¸­...';
}

function initGame(size) {
  // çŠ¶æ…‹ã®åˆæœŸåŒ–
  gameState.boardSize = size;
  gameState.walls = [];
  gameState.turn = 1;
  gameState.winner = null;
  gameState.mode = 'move';
  
  // ã‚«ãƒ™ã®æšæ•°è¨ˆç®— (å…¬å¼ãƒ«ãƒ¼ãƒ«ã«è¿‘ã„æ¯”ç‡)
  const initialWalls = size === 9 ? 10 : Math.floor((size * size) / 8);
  gameState.wallsLeft = { 1: initialWalls, 2: initialWalls };

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆæœŸä½ç½® (å·¦ vs å³)
  // é’(1): å·¦ç«¯ã®ä¸­å¤® -> å³ç«¯ã‚’ç›®æŒ‡ã™
  // èµ¤(2): å³ç«¯ã®ä¸­å¤® -> å·¦ç«¯ã‚’ç›®æŒ‡ã™
  const center = Math.floor(size / 2);
  gameState.players = {
    1: { row: center, col: 0, goalCol: size - 1 },
    2: { row: center, col: size - 1, goalCol: 0 }
  };

  // UIåˆ‡ã‚Šæ›¿ãˆ
  document.getElementById('setup-screen').classList.add('d-none');
  document.getElementById('game-screen').classList.remove('d-none');
  
  renderBoard();
  updateStatusUI();
  updateTurnIndicator();
}

// --- 3. æç”»ãƒ­ã‚¸ãƒƒã‚¯ (Rendering) ---

function renderBoard() {
  const board = document.getElementById('board');
  const size = gameState.boardSize;
  
  // ã‚°ãƒªãƒƒãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®å‹•çš„ç”Ÿæˆ
  board.innerHTML = '';
  board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
  board.style.gridTemplateRows = `repeat(${size}, 1fr)`;
  
  // ã‚¹ãƒãƒ›ã§ã‚‚è¦‹ã‚„ã™ã„ã‚µã‚¤ã‚ºè¨ˆç®—
  const boardWidth = Math.min(window.innerWidth - 40, 600); // æœ€å¤§600px
  // é«˜ã•ã‚‚å¹…ã¨åŒã˜ã«ã—ã¦æ­£æ–¹å½¢ã«
  board.style.width = `${boardWidth}px`;
  board.style.height = `${boardWidth}px`;

  // ãƒã‚¹ç›®ã®ç”Ÿæˆ
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.row = r;
      cell.dataset.col = c;
      
      // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
      cell.onclick = () => handleCellClick(r, c);
      
      // â–¼ è¿½åŠ : ãƒã‚¦ã‚¹ã‚ªãƒ¼ãƒãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå£ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ï¼‰
      cell.onmouseenter = () => showWallPreview(r, c);
      cell.onmouseleave = () => clearWallPreview();
      
      board.appendChild(cell);
    }
  }

  // ç›¤é¢ã‹ã‚‰å‡ºãŸã¨ãã‚‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ¶ˆã™
  board.onmouseleave = () => clearWallPreview();

  drawPawns();
  drawWalls(boardWidth, size);
  highlightValidMoves();
}

function drawPawns() {
  // æ—¢å­˜ã®ã‚³ãƒã‚’å‰Šé™¤
  document.querySelectorAll('.pawn').forEach(el => el.remove());
  
  Object.keys(gameState.players).forEach(pid => {
    const p = gameState.players[pid];
    const cell = document.querySelector(`.cell[data-row='${p.row}'][data-col='${p.col}']`);
    if (cell) {
      const pawn = document.createElement('div');
      pawn.className = `pawn p${pid}`;
      pawn.innerHTML = pid === '1' ? 'ğŸ”µ' : 'ğŸ”´'; // ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¢ã‚¤ã‚³ãƒ³
      pawn.style.display = 'flex';
      pawn.style.justifyContent = 'center';
      pawn.style.alignItems = 'center';
      pawn.style.fontSize = '1.2em';
      cell.appendChild(pawn);
    }
  });
}

function drawWalls(boardWidth, size) {
  // æ—¢å­˜ã®ã‚«ãƒ™ã‚’å‰Šé™¤
  document.querySelectorAll('.wall').forEach(el => el.remove());
  
  const board = document.getElementById('board');
  // ã‚»ãƒ«ã®å®Ÿã‚µã‚¤ã‚ºã‚’å–å¾—ï¼ˆæ­£ç¢ºãªé…ç½®ã®ãŸã‚ï¼‰
  const cells = document.querySelectorAll('.cell');
  if (cells.length === 0) return;
  
  const cellRect = cells[0].getBoundingClientRect();
  const gap = 4; // CSSã®gap
  
  gameState.walls.forEach(w => {
    createWallElement(board, cellRect, gap, w.row, w.col, w.orientation, false);
  });
}

// ã‚«ãƒ™è¦ç´ ã‚’ä½œæˆã™ã‚‹å…±é€šé–¢æ•° (æç”»ã¨ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§å…±æœ‰)
function createWallElement(container, cellRect, gap, r, c, orientation, isPreview) {
  const wall = document.createElement('div');
  wall.className = isPreview ? 'wall-preview' : 'wall';
  
  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ«
  if (isPreview) {
    wall.style.position = 'absolute';
    wall.style.borderRadius = '4px';
    wall.style.zIndex = '100'; // æœ€å‰é¢
    wall.style.pointerEvents = 'none'; // ã‚¯ãƒªãƒƒã‚¯ã‚’é‚ªé­”ã—ãªã„
    wall.style.opacity = '0.6';
  }

  // ã‚«ãƒ™ã®æç”»ä½ç½®è¨ˆç®—
  if (orientation === 'h') {
    // æ¨ªå‘ã: ä¸‹ã®å¢ƒç•Œç·š
    const cellTarget = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
    if(cellTarget) {
      wall.style.height = `${gap * 2}px`; // å°‘ã—å¤ªã‚ã«
      wall.style.width = `${(cellRect.width * 2) + gap}px`;
      wall.style.top = `${cellTarget.offsetTop + cellRect.height - (gap/2)}px`;
      wall.style.left = `${cellTarget.offsetLeft}px`;
    }
  } else {
    // ç¸¦å‘ã: å³ã®å¢ƒç•Œç·š
    const cellTarget = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
    if(cellTarget) {
      wall.style.width = `${gap * 2}px`;
      wall.style.height = `${(cellRect.height * 2) + gap}px`;
      wall.style.top = `${cellTarget.offsetTop}px`;
      wall.style.left = `${cellTarget.offsetLeft + cellRect.width - (gap/2)}px`;
    }
  }
  container.appendChild(wall);
  return wall;
}

// â–¼ è¿½åŠ : ã‚«ãƒ™ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
function showWallPreview(r, c) {
  if (gameState.mode !== 'wall' || gameState.winner) return;

  clearWallPreview();
  
  const board = document.getElementById('board');
  const cells = document.querySelectorAll('.cell');
  if (cells.length === 0) return;
  const cellRect = cells[0].getBoundingClientRect();
  const gap = 4;

  // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã—ã¦è‰²ã‚’æ±ºã‚ã‚‹
  let isValid = true;
  
  // ç¯„å›²å¤–ãƒã‚§ãƒƒã‚¯
  if (gameState.wallOrientation === 'v' && r >= gameState.boardSize - 1) isValid = false; // ä¸‹ã«ã¯ã¿å‡ºã‚‹
  if (gameState.wallOrientation === 'v' && c >= gameState.boardSize - 1) isValid = false; // å³ã«ã¯ã¿å‡ºã‚‹
  if (gameState.wallOrientation === 'h' && c >= gameState.boardSize - 1) isValid = false; // å³ã«ã¯ã¿å‡ºã‚‹
  if (gameState.wallOrientation === 'h' && r >= gameState.boardSize - 1) isValid = false; // ä¸‹ã«ã¯ã¿å‡ºã‚‹

  // ãƒ«ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯
  if (isValid) {
    const error = validateWall(r, c, gameState.wallOrientation);
    if (error) isValid = false;
  }

  const wall = createWallElement(board, cellRect, gap, r, c, gameState.wallOrientation, true);
  
  // è‰²ã®é©ç”¨
  if (isValid) {
    wall.style.backgroundColor = '#ffca28'; // æœ‰åŠ¹ãªã‚‰é»„è‰²ï¼ˆã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚«ãƒ©ãƒ¼ï¼‰
    wall.style.border = '2px dashed #3e2723';
  } else {
    wall.style.backgroundColor = '#ff5252'; // ç„¡åŠ¹ãªã‚‰èµ¤
    wall.style.border = '2px dashed white';
  }
}

// â–¼ è¿½åŠ : ã‚«ãƒ™ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ¶ˆå»
function clearWallPreview() {
  document.querySelectorAll('.wall-preview').forEach(el => el.remove());
}


// --- 4. æ“ä½œãƒ­ã‚¸ãƒƒã‚¯ (Interaction) ---

// ãƒã‚¹ç›®ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã¨ãï¼ˆç§»å‹• or ã‚«ãƒ™è¨­ç½®ã®èµ·ç‚¹ï¼‰
function handleCellClick(r, c) {
  if (gameState.winner) return;

  if (gameState.mode === 'move') {
    // ç§»å‹•å‡¦ç†
    tryMove(r, c);
  } else {
    // ã‚«ãƒ™è¨­ç½®å‡¦ç†
    // ç«¯ã£ã“ï¼ˆå³ç«¯ã€ä¸‹ç«¯ï¼‰ã‚’é¸æŠã—ãŸå ´åˆã®ã‚¬ãƒ¼ãƒ‰
    if (r >= gameState.boardSize - 1 && gameState.wallOrientation === 'v') {
         Swal.fire({
           icon: 'info',
           title: getRubyText('ç½®(ãŠ)ã‘ã¾ã›ã‚“'),
           text: 'ä¸‹(ã—ãŸ)ã«ã¯ã¿å‡º(ã )ã—ã¦ã—ã¾ã„ã¾ã™ã€‚',
           timer: 1500,
           showConfirmButton: false
         });
         return;
    }
    // ãã®ä»–ã®ç¯„å›²å¤–ã‚¬ãƒ¼ãƒ‰ã¯ä»¥å‰ã¨åŒã˜
    if (c >= gameState.boardSize - 1 && gameState.wallOrientation === 'h') {
         Swal.fire({ icon: 'info', title: getRubyText('ç½®(ãŠ)ã‘ã¾ã›ã‚“'), text: 'å³(ã¿ã)ã«ã¯ã¿å‡º(ã )ã—ã¦ã—ã¾ã„ã¾ã™ã€‚', timer: 1500, showConfirmButton: false });
         return;
    }
    if (gameState.wallOrientation === 'h' && r >= gameState.boardSize - 1) {
         Swal.fire({ icon: 'info', title: getRubyText('ç½®(ãŠ)ã‘ã¾ã›ã‚“'), text: 'å¤–æ (ãã¨ã‚ã)ã«ã¯ç½®(ãŠ)ã‘ã¾ã›ã‚“', timer: 1000, showConfirmButton: false });
         return;
    }
    if (gameState.wallOrientation === 'v' && c >= gameState.boardSize - 1) {
         Swal.fire({ icon: 'info', title: getRubyText('ç½®(ãŠ)ã‘ã¾ã›ã‚“'), text: 'å¤–æ (ãã¨ã‚ã)ã«ã¯ç½®(ãŠ)ã‘ã¾ã›ã‚“', timer: 1000, showConfirmButton: false });
         return;
    }

    tryPlaceWall(r, c, gameState.wallOrientation);
  }
}

function tryMove(r, c) {
  const pid = gameState.turn;
  const player = gameState.players[pid];
  
  // æœ‰åŠ¹ãªç§»å‹•ã‹ãƒã‚§ãƒƒã‚¯
  if (isValidMove(player, r, c)) {
    // ç§»å‹•å®Ÿè¡Œ
    player.row = r;
    player.col = c;
    
    // å‹åˆ©åˆ¤å®š
    if (player.col === player.goalCol) {
      handleWin(pid);
    } else {
      switchTurn();
    }
  }
}

function tryPlaceWall(r, c, orientation) {
  const pid = gameState.turn;
  
  // ã‚«ãƒ™ã®æ®‹ã‚Šæšæ•°ãƒã‚§ãƒƒã‚¯
  if (gameState.wallsLeft[pid] <= 0) {
    Swal.fire({
      icon: 'warning',
      title: getRubyText('ã‚«ãƒ™ãŒã‚ã‚Šã¾ã›ã‚“ï¼'),
      html: getRubyText('ã‚‚ã†ã‚«ãƒ™ã‚’<ruby>ä½¿<rt>ã¤ã‹</rt></ruby>ã„<ruby>åˆ‡<rt>ã</rt></ruby>ã£ã¦ã—ã¾ã„ã¾ã—ãŸã€‚<br>ã‚³ãƒã‚’<ruby>å‹•<rt>ã†ã”</rt></ruby>ã‹ã—ã¦ãã ã•ã„ã€‚'),
      confirmButtonColor: '#ffca28'
    });
    return;
  }

  // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  const errorMsg = validateWall(r, c, orientation);
  if (errorMsg) {
    Swal.fire({
      icon: 'error',
      title: getRubyText('ç½®(ãŠ)ã‘ã¾ã›ã‚“'),
      text: errorMsg,
      toast: true,
      position: 'top-end',
      showConfirmButton: false,
      timer: 2000
    });
    return;
  }

  // è¨­ç½®å®Ÿè¡Œ
  gameState.walls.push({ row: r, col: c, orientation: orientation });
  gameState.wallsLeft[pid]--;
  
  switchTurn();
}

function switchTurn() {
  gameState.turn = gameState.turn === 1 ? 2 : 1;
  renderBoard(); // å†æç”»
  updateStatusUI();
  updateTurnIndicator();
}

function handleWin(pid) {
  gameState.winner = pid;
  renderBoard();
  
  const teamName = pid === 1 ? "é’(ã‚ãŠ)ãƒãƒ¼ãƒ " : "èµ¤(ã‚ã‹)ãƒãƒ¼ãƒ ";
  const color = pid === 1 ? "#2979ff" : "#ff1744";
  
  Swal.fire({
    title: getRubyText('å‹è² (ã—ã‚‡ã†ã¶)ã‚ã‚Šï¼'),
    html: `<h2 style="color:${color}; font-weight:bold;">ğŸ‰ ${getRubyText(pid === 1 ? 'é’(ã‚ãŠ)' : 'èµ¤(ã‚ã‹)')}ãƒãƒ¼ãƒ ã®<ruby>å‹<rt>ã‹</rt></ruby>ã¡ï¼ ğŸ‰</h2>`,
    icon: 'success',
    background: '#fff9c4',
    confirmButtonText: getRubyText('ã‚‚ã†ä¸€å›(ã„ã£ã‹ã„)éŠ(ã‚ã)ã¶'),
    confirmButtonColor: color,
    allowOutsideClick: false
  }).then((result) => {
    if (result.isConfirmed) {
      // ãƒªã‚»ãƒƒãƒˆã—ã¦ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ç”»é¢ã¸
      document.getElementById('setup-screen').classList.remove('d-none');
      document.getElementById('game-screen').classList.add('d-none');
    }
  });
}

// --- 5. ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ & ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  (Logic) ---

// ç§»å‹•åˆ¤å®š
function isValidMove(currentP, targetR, targetC) {
  // ç¾åœ¨åœ°ã¨ç›®çš„åœ°ãŒåŒã˜ãªã‚‰ç„¡åŠ¹
  if (currentP.row === targetR && currentP.col === targetC) return false;

  const opponentPid = gameState.turn === 1 ? 2 : 1;
  const opponent = gameState.players[opponentPid];
  
  // 1. éš£æ¥ç§»å‹•ãƒã‚§ãƒƒã‚¯
  const dist = Math.abs(currentP.row - targetR) + Math.abs(currentP.col - targetC);
  
  // é€šå¸¸ç§»å‹• (è·é›¢1)
  if (dist === 1) {
    // ç›¸æ‰‹ãŒã„ã‚‹å ´æ‰€ã«ã¯è¡Œã‘ãªã„
    if (targetR === opponent.row && targetC === opponent.col) return false;
    return !isWallBlocking(currentP.row, currentP.col, targetR, targetC);
  }
  
  // ã‚¸ãƒ£ãƒ³ãƒ—ç§»å‹• (è·é›¢2)
  if (dist === 2) {
    // ç›´ç·šã‚¸ãƒ£ãƒ³ãƒ—
    if ((currentP.row === targetR || currentP.col === targetC)) {
       // é–“ã«ç›¸æ‰‹ãŒã„ã‚‹ã‹ï¼Ÿ
       const midR = (currentP.row + targetR) / 2;
       const midC = (currentP.col + targetC) / 2;
       if (opponent.row === midR && opponent.col === midC) {
         // è‡ªåˆ†ã®ç›®ã®å‰ã«ã‚«ãƒ™ãŒãªãã€ç›¸æ‰‹ã®å¾Œã‚ã«ã‚‚ã‚«ãƒ™ãŒãªã„
         return !isWallBlocking(currentP.row, currentP.col, midR, midC) && 
                !isWallBlocking(midR, midC, targetR, targetC);
       }
    }
  }
  return false;
}

// ã‚«ãƒ™åˆ¤å®š (ç§»å‹•ç”¨)
function isWallBlocking(r1, c1, r2, c2) {
  for (const w of gameState.walls) {
    if (w.orientation === 'h') {
      // æ¨ªã‚«ãƒ™: w.row ã¨ w.row+1 ã®å¢ƒç•Œç·šä¸Š
      // ç§»å‹•ãŒç¸¦æ–¹å‘(rãŒå¤‰ã‚ã‚‹)ã§ã€ã‹ã¤ã‚«ãƒ™ã®è¡Œã‚’è·¨ãå ´åˆ
      // ã‚«ãƒ™ã¯ col ã‹ã‚‰ col+1 ã¾ã§å­˜åœ¨
      if (Math.abs(r1 - r2) === 1) {
        const borderRow = Math.min(r1, r2); // ã‚«ãƒ™ãŒã‚ã‚‹ã¹ãè¡Œ (rowã¨row+1ã®é–“ = row)
        if (w.row === borderRow) {
           // åˆ—ãŒã‚«ãƒ™ã®ç¯„å›²å†…ã‹ (c1ã¯ç§»å‹•å…ƒã€c2ã‚‚åŒã˜ã¯ãšã ãŒã€ã“ã“ã¯åˆ—ãŒå¤‰ã‚ã‚‰ãªã„å‰æ)
           // æ¨ªç§»å‹•ãªã‚‰ã“ã“ã«ã¯æ¥ãªã„ã¯ãšã ãŒå¿µã®ãŸã‚
           // ç¸¦ç§»å‹•ãªã®ã§ c1 === c2
           if (c1 === w.col || c1 === w.col + 1) return true;
        }
      }
    } else {
      // ç¸¦ã‚«ãƒ™: w.col ã¨ w.col+1 ã®å¢ƒç•Œç·šä¸Š
      if (Math.abs(c1 - c2) === 1) {
        const borderCol = Math.min(c1, c2);
        if (w.col === borderCol) {
           if (r1 === w.row || r1 === w.row + 1) return true;
        }
      }
    }
  }
  return false;
}

// ã‚«ãƒ™è¨­ç½®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
function validateWall(r, c, orientation) {
  // 1. é‡ãªã‚Šãƒã‚§ãƒƒã‚¯
  for (const w of gameState.walls) {
    if (w.row === r && w.col === c && w.orientation === orientation) return "ãã“ã«ã‚«ãƒ™ã¯ã‚ã‚Šã¾ã™ã€‚";
    if (w.row === r && w.col === c) return "ã‚«ãƒ™ãŒã‚¯ãƒ­ã‚¹ã—ã¦ã—ã¾ã„ã¾ã™ã€‚"; // åå­—äº¤å·®ç¦æ­¢
    
    // ä¸€éƒ¨é‡ãªã‚Š (ç›´åˆ—é…ç½®ã§ã®è¢«ã‚Š)
    // æ¨ªã‚«ãƒ™åŒå£«: è¡ŒãŒåŒã˜ã§ã€åˆ—ãŒ1ã‚ºãƒ¬ã¦ã„ã‚‹ã¨é‡ãªã‚‹ (é•·ã•2ãªã®ã§)
    if (orientation === 'h' && w.orientation === 'h' && w.row === r && Math.abs(w.col - c) === 1) return "ã‚«ãƒ™ãŒé‡(ã‹ã•)ãªã‚Šã¾ã™ã€‚";
    // ç¸¦ã‚«ãƒ™åŒå£«: åˆ—ãŒåŒã˜ã§ã€è¡ŒãŒ1ã‚ºãƒ¬ã¦ã„ã‚‹ã¨é‡ãªã‚‹
    if (orientation === 'v' && w.orientation === 'v' && w.col === c && Math.abs(w.row - r) === 1) return "ã‚«ãƒ™ãŒé‡(ã‹ã•)ãªã‚Šã¾ã™ã€‚";
  }

  // 2. çµŒè·¯å°é–ãƒã‚§ãƒƒã‚¯ (BFS)
  gameState.walls.push({ row: r, col: c, orientation: orientation }); // ä»®ç½®ã
  
  const p1CanReach = pathExists(1);
  const p2CanReach = pathExists(2);
  
  gameState.walls.pop(); // å…ƒã«æˆ»ã™
  
  if (!p1CanReach || !p2CanReach) {
    return "ã‚´ãƒ¼ãƒ«ã¸ã®é“(ã¿ã¡)ãŒãªããªã£ã¦ã—ã¾ã„ã¾ã™ï¼";
  }
  
  return null; // OK
}

// BFSã«ã‚ˆã‚‹çµŒè·¯æ¢ç´¢
function pathExists(pid) {
  const p = gameState.players[pid];
  const goalCol = p.goalCol;
  const size = gameState.boardSize;
  
  let queue = [{ r: p.row, c: p.col }];
  let visited = new Set();
  visited.add(`${p.row},${p.col}`);
  
  const directions = [
    {dr: -1, dc: 0}, {dr: 1, dc: 0}, {dr: 0, dc: -1}, {dr: 0, dc: 1}
  ];
  
  while (queue.length > 0) {
    const {r, c} = queue.shift();
    
    if (c === goalCol) return true; // åˆ°é”ï¼
    
    for (const d of directions) {
      const nr = r + d.dr;
      const nc = c + d.dc;
      
      if (nr >= 0 && nr < size && nc >= 0 && nc < size) {
        if (!visited.has(`${nr},${nc}`)) {
          // ç§»å‹•å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚«ãƒ™ãŒãªã„ã‹ï¼‰
          if (!isWallBlocking(r, c, nr, nc)) {
            visited.add(`${nr},${nc}`);
            queue.push({ r: nr, c: nc });
          }
        }
      }
    }
  }
  return false;
}

// --- 6. UI ãƒ˜ãƒ«ãƒ‘ãƒ¼ (UI Helpers) ---

function updateStatusUI() {
  const t = gameState.turn;
  
  // ã‚«ãƒ™æ®‹æ•°è¡¨ç¤º
  document.getElementById('p1-walls').textContent = gameState.wallsLeft[1];
  document.getElementById('p2-walls').textContent = gameState.wallsLeft[2];
  
  // ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  document.getElementById('p1-panel').className = `card p-2 text-center shadow-sm h-100 justify-content-center ${t === 1 ? 'border-primary bg-light' : ''}`;
  document.getElementById('p2-panel').className = `card p-2 text-center shadow-sm h-100 justify-content-center ${t === 2 ? 'border-danger bg-light' : ''}`;
  
  // ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹
  const isMove = gameState.mode === 'move';
  const btnMove = document.getElementById('btn-mode-move');
  const btnWall = document.getElementById('btn-mode-wall');
  
  if (isMove) {
    btnMove.classList.add('btn-primary-pop');
    btnMove.classList.remove('btn-light');
    btnWall.classList.add('btn-light');
    btnWall.classList.remove('btn-pop'); // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ã¯è‰²ä»˜ããªã®ã§popã‚¯ãƒ©ã‚¹ä»˜ã‘æ›¿ãˆ
    btnWall.style.backgroundColor = '#f8f9fa';
    btnWall.style.color = '#000';
    
    document.getElementById('wall-controls').classList.add('d-none');
    document.getElementById('move-hint').classList.remove('d-none');
    clearWallPreview(); // ãƒ¢ãƒ¼ãƒ‰å¤‰æ›´æ™‚ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ¶ˆã™
  } else {
    btnMove.classList.add('btn-light');
    btnMove.classList.remove('btn-primary-pop');
    
    btnWall.classList.remove('btn-light');
    // ã‚«ãƒ™ãƒ¢ãƒ¼ãƒ‰ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–è‰²ï¼ˆé»„è‰²ï¼‰
    btnWall.style.backgroundColor = '#ffca28';
    btnWall.style.color = '#3e2723';
    
    document.getElementById('wall-controls').classList.remove('d-none');
    document.getElementById('move-hint').classList.add('d-none');
    
    // å£å‘ããƒœã‚¿ãƒ³ã®è¡¨ç¤ºæ›´æ–°
    const oriBtn = document.getElementById('btn-rotate-wall');
    oriBtn.innerHTML = gameState.wallOrientation === 'v' 
      ? 'ä»Šã¯ <b>ã‚¿ãƒ†</b><br><small class="fs-6"><ruby>æŠ¼<rt>ãŠ</rt></ruby>ã™ã¨ãƒ¨ã‚³</small>' 
      : 'ä»Šã¯ <b>ãƒ¨ã‚³</b><br><small class="fs-6"><ruby>æŠ¼<rt>ãŠ</rt></ruby>ã™ã¨ã‚¿ãƒ†</small>';
  }
}

function updateTurnIndicator() {
  const msgEl = document.getElementById('game-message');
  if (gameState.turn === 1) {
    msgEl.innerHTML = getRubyText('é’(ã‚ãŠ)ãƒãƒ¼ãƒ ã®ç•ª(ã°ã‚“)ã§ã™');
    msgEl.style.color = 'var(--p1-color)';
    msgEl.style.borderColor = 'var(--p1-color)';
  } else {
    msgEl.innerHTML = getRubyText('èµ¤(ã‚ã‹)ãƒãƒ¼ãƒ ã®ç•ª(ã°ã‚“)ã§ã™');
    msgEl.style.color = 'var(--p2-color)';
    msgEl.style.borderColor = 'var(--p2-color)';
  }
}

function toggleWallOrientation() {
  gameState.wallOrientation = gameState.wallOrientation === 'v' ? 'h' : 'v';
  updateStatusUI();
  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®å‘ãã‚‚æ›´æ–°ã—ãŸã„ã®ã§ã€ä¸€åº¦æ¶ˆã™ï¼ˆãƒã‚¦ã‚¹å‹•ãã¨å†æç”»ã•ã‚Œã‚‹ï¼‰
  clearWallPreview();
}

function setMode(m) {
  gameState.mode = m;
  updateStatusUI();
  renderBoard(); // ãƒã‚¤ãƒ©ã‚¤ãƒˆæ›´æ–°ã®ãŸã‚
}

function highlightValidMoves() {
  // ç§»å‹•ãƒ¢ãƒ¼ãƒ‰ã‹ã¤å‹è² ãŒã¤ã„ã¦ã„ãªã„æ™‚ã ã‘
  if (gameState.mode !== 'move' || gameState.winner) return;

  const pid = gameState.turn;
  const p = gameState.players[pid];
  const size = gameState.boardSize;
  
  // å…¨ã‚»ãƒ«èµ°æŸ»ã—ã¦ã€ç§»å‹•å¯èƒ½ãªã‚‰ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è¿½åŠ 
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      if (isValidMove(p, r, c)) {
        const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
        if (cell) {
          const mark = document.createElement('div');
          mark.className = 'valid-move';
          cell.appendChild(mark);
        }
      }
    }
  }
}

// ãƒ«ãƒ“å¤‰æ›ãƒ˜ãƒ«ãƒ‘ãƒ¼
function getRubyText(text) {
  return text.replace(/([ä¸€-é¾ ]+)\(([ã-ã‚“ã‚¡-ãƒ³]+)\)/g, '<ruby>$1<rt>$2</rt></ruby>');
}

function showRules() {
  Swal.fire({
    title: getRubyText('ã‚ãã³ã‹ãŸ'),
    width: '600px',
    html: `
      <style>
        .rule-step { margin-bottom: 20px; text-align: left; padding: 15px; background: #f9fbe7; border-radius: 10px; border: 2px solid #e6ee9c; }
        .rule-title { font-weight: bold; color: #33691e; font-size: 1.2em; display: flex; align-items: center; margin-bottom: 10px; }
        .rule-icon { font-size: 1.5em; margin-right: 10px; background: #fff; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .rule-visual { text-align: center; margin: 10px 0; font-size: 2em; line-height: 1.2; }
        .rule-desc { font-size: 0.95em; line-height: 1.6; }
      </style>
      <div style="font-family: 'Zen Maru Gothic', sans-serif;">
        <!-- Rule 1 -->
        <div class="rule-step">
          <div class="rule-title"><span class="rule-icon">1</span> ã‚´ãƒ¼ãƒ«ã‚’<ruby>ç›®æŒ‡<rt>ã‚ã–</rt></ruby>ã›ï¼</div>
          <div class="rule-visual">ğŸ”µ â¡ ğŸ &nbsp;&nbsp;&nbsp; ğŸ â¬… ğŸ”´</div>
          <div class="rule-desc"><ruby>é’<rt>ã‚ãŠ</rt></ruby>ã¯<ruby>å³<rt>ã¿ã</rt></ruby>ã¸ã€<ruby>èµ¤<rt>ã‚ã‹</rt></ruby>ã¯<ruby>å·¦<rt>ã²ã ã‚Š</rt></ruby>ã®ç«¯(ã¯ã—)ã¾ã§<ruby>é€²<rt>ã™ã™</rt></ruby>ã‚ã°<ruby>å‹<rt>ã‹</rt></ruby>ã¡ï¼</div>
        </div>
        <!-- Rule 2 -->
        <div class="rule-step">
          <div class="rule-title"><span class="rule-icon">2</span> ã©ã£ã¡ã‹1ã¤</div>
          <div class="rule-visual">ğŸƒ <ruby>æ­©<rt>ã‚ã‚‹</rt></ruby>ã <span style="font-size:0.7em; color:#999;">ã¾ãŸã¯</span> ğŸš§ ã‚«ãƒ™</div>
          <div class="rule-desc"><ruby>è‡ªåˆ†<rt>ã˜ã¶ã‚“</rt></ruby>ã®<ruby>ç•ª<rt>ã°ã‚“</rt></ruby>ã«ã€Œã‚³ãƒã‚’1ãƒã‚¹<ruby>å‹•<rt>ã†ã”</rt></ruby>ã‹ã™ã€ã‹ã€Œã‚«ãƒ™ã‚’<ruby>ç½®<rt>ãŠ</rt></ruby>ãã€ã‹é¸(ãˆã‚‰)ã¼ã†ã€‚</div>
        </div>
        <!-- Rule 3 -->
        <div class="rule-step">
          <div class="rule-title"><span class="rule-icon">3</span> <ruby>é‚ªé­”<rt>ã˜ã‚ƒã¾</rt></ruby>ã—ã‚ˆã†</div>
          <div class="rule-visual">ğŸš§ğŸƒğŸš§ &nbsp; ğŸ†—<br><span style="font-size:0.5em; color:red;">âŒ <ruby>é–‰<rt>ã¨</rt></ruby>ã˜<ruby>è¾¼<rt>ã“</rt></ruby>ã‚ã¯ãƒ€ãƒ¡ï¼</span></div>
          <div class="rule-desc"><ruby>ç›¸æ‰‹<rt>ã‚ã„ã¦</rt></ruby>ã®<ruby>é“<rt>ã¿ã¡</rt></ruby>ã‚’ãµã•ã”ã†ï¼ã§ã‚‚ã€ã‚´ãƒ¼ãƒ«ã¸ã®<ruby>é“<rt>ã¿ã¡</rt></ruby>ã‚’<ruby>å®Œå…¨<rt>ã‹ã‚“ãœã‚“</rt></ruby>ã«ãªãã™ã®ã¯åå‰‡(ã¯ã‚“ãã)ã ã‚ˆã€‚</div>
        </div>
      </div>
    `,
    confirmButtonText: getRubyText('ã‚ã‹ã£ãŸï¼')
  });
}
</script>
